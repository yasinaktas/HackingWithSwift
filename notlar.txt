Camel Case swiftte standart -> yasinAktas
Swiftte satır sonunda virgül kullanmıyoruz ama aynı satırda birden fazla kod yazacaksak virgülle ayırırız.
Multiline Strings için """ kullanıyoruz. Fakat stringden izole olmalılar (üstte ve altta ayrı olarak)
.count -> Parantezi yok çünkü swifte iş yaptırmıyoruz
.uppercased()
.hasPrefix("A B")
.hasSuffix(".png")
+= -= *= /= -> Compound assignment operators
.isMultiple(of:3)
Swift farklı türleri karıştırmamızı istemez -> let c = a + Int(b)
.toggle() -> !

ARRAYS
var colors = [String]
var colors: [String] = ["red","purple"]
var colors = Array<String>()
var colors = ["red","purple"]
colors.append("yellow")
colors.remove(at:1)
colors.removeAll()
colors.count

DICTIONARIES
let employee = ["name":"yasin","surname":"aktas"]
print(employee["name"]) -> eğer boşsa hata verebilir -> default eklemeliyiz
print(employee["name",default:"not_exist"])
var employees = [String:Int]()
Birden fazla ekleme yapamıyoruz
Index yok
.count

SETS
Burada da index yok
Duplicate yok
Set() içine array alıyor ve duplicateleri eliyor
var people = Set<String>()
Sıra olmadığı için append değil de insert kullanıyoruz
people.insert("yasin")
Çok optimize bir şekilde elemanları dizdiği için .contains("yasin") çalıştırmak normal array'e kıyasla çok daha hızlı sonuç verir
.count
.sorted()

ENUMS
Elimizdeki benzer verileri daha kolay gruplayabilmek ve ihtiyacımız olduğunda daha rahat kullanabilmek için kullanırız, haftanın günlerini sayı olarak tutmaktansa isimleriyle tutmak işimizi çok daha kolaylaştırır
enum Weekday{
	case monday
	case tuesday
	case wednesday
	case thursday
	case friday
}
enum Weekday{
	case monday, tuesday, wednesday, thursday, friday
}
var day = Weekday.monday
day = Weekday.tuesday
day = .wednesday

TYPE ANNOTATION
Değişken tanımlarken türünü açıkça belirtmemizdir -> Belirtmiyorsak type inference olur
var name : String
var score : Double = 0 -> type annotation yapmasaydık swift bu değişkenin integer olduğuna karar verecekti
var names: [String] = ["yasin"
,"celal","ömer"]
var names = [String]() -> tercih edilen
var names:[String] = [String]()
var user: [String,String] = ["yasin":"aktas"]
var user: Set<String> = Set(["yasin"])
Değişkenimiz başta boş olacaksa type annotation kullanmamız gerekir
Internetten veri çekeceksek kullanmamız gerekebilir, swift gelecek verinin tipini kestiremeyebilir, yardımcı olmamız gerekir
Type inference kodu kısa olmasını sağlar (Yazılımcıdan yazılımcıya değişir)

IF
İki stringi alfabetik olarak karşılaştırabiliyoruz
Bir string boş mu değil mi diye kontrol etmek istediğimizde .isEmpty en ideal olandır, bundan sonra  == "" gelir, sonra .count==0
Enum değerlerini de karşılaştırabiliyoruz, önce yazılan küçük değer alıyor diyebiliriz
enum Size : Comparable{
	case small
	case medium
	case large
}
Size.small < Size.large
Farklı türler karşılaştırılamaz, örneğin int ve double

SWITCH
var size = Size.small
switch size{
	case small:
		print("small")
		fallthrough -> sonrakileri de gerçekleştir, doğru olmasa bile
	case large:
		print("large")
	default:
		print("unknown")
}
enum tarzı değişkenlerde tüm seçenekleri eklemeliyiz, yoksa default eklemeliyiz, sayılarla ilgiliyse default eklemeliyiz

TERNARY OPERATOR (WTF)
What-True-False
var status = 10 > 15 ? "Smaller" : "Bigger"
print(10 > 15 ? "Smaller" : "Bigger")

FOR LOOP
for name in names{
	print("My name is \(name)")
}
-> name'i kendisi oluşturdu
for i in 1...5{
}
for i in 1..<5{
}
for _ in 1...5{
}
_ -> değişkeni kullanmayacaksak underscore kullanıyoruz

RANGE
print(names[1...3])
print(names[1...])

WHILE LOOP
var index = 0
while index < 10{
	index++
}
Serverdan bilgi alıyorsak, beklediğimiz sonuç gerçekleşene kadar beklememiz gerekiyosa while kullanırız

RANDOM
let id = Int.random(in: 1...1000)

CONTINUE
Döngüde continue denk geldiğinde o iterasyon atlanır

BREAK
Döngüde break denk geldiğinde döngü sonlandırılır

LABELED STATEMENT
nested looplarda herhangi bir döngü içi break veya continue kullanmamız gerekirse
outer_loop for i in 1..5{
	break outer_loop
}

FUNCTIONS
func displayMessage(){
	print("Welcome")
}
func displayName(name:String){
	print(name)
}
displayName(name:"Yasin") -> Parametrenin başına adını da yazıyoruz, bu diğer dillerde yaygın değil fakat okunurluğu kolaylaştıryor
Eğer parametre adının başına underscore _ koyarsa, fonksiyonu çağırdığımızda bu parametre adını yazmayız, aslında iki isim yazabiliriz ilki external(argument name) ikincisi internal(parameter name) isim olur
func displayName(_ name:String){
	print(name)
}
displayName("Yasin")
func displayName(isim name:String){
	print(name)
}
displayName(isim:"Yasin")
Parameter -> Placeholder
Argument -> Actual Value
(Verilen argument, alınan parameter denilebilir)
Fonksiyon içinde oluşturulan değişkenler, fonksiyon tamamlanınca otomatik olarak kaldırılır

RETURN
Süslü parantezden önce ok koyup veritipi belirtiyoruz, sonra fonksiyon içinde bu veri tipinde return yapıyoruz
func sumNumbers (num1: Int, num2: Int) -> Int {
	return num1 + num2
}
Fonksiyon tek satırdan oluşuyorsa return ifadesini kaldırabiliriz -> Expressions are things that can be assigned to a variable, or printed using print() -> Ternary de kullanabilirz tek satır için

MULTIPLE RETURN
Return type'ı array veya dictionary yaparak birden fazla değeri return edebiliriz (Kötü yöntemler)
Return type'ı sanki parametre parantezleri gibi yazabiliriz ve buna TUPLES denir
func getUser() -> (firstName: String, lastName: String) {
    (firstName: "Taylor", lastName: "Swift")
}
let user = getUser()
print("Name: \(user.firstName) \(user.lastName)")
user.0, user.1 de olur
Dictionary'e göre ana avantajı return edeceğimiz değerin kesinlikle var olacak olmasıdır, dictionary'de default kullanmamız gerekecekti
let (firstName, lastName) = getUser()
let (firstName, _) = getUser()

DEFAULT PARAMETER VALUE
Fonksiyon parametresine değer atarsak, fonksiyon çağırılırken bu parametre eklenmeden de çağırılabilir.
func sumNumbers(num1:Int,num2:Int = 5) -> Int{
	num1 + num2
}
sumNumbers(num1:10)
.removeAll(keepingCapacity:true) -> bir arrayimiz var, içini boşaltacağız fakat kapladığı alan kalsın istiyoruz

ERROR HANDLING
Öncelikle hataları içeren bir enum oluşturuyoruz
enum PasswordError: Error{
	case short,obvious
}
Sonra errorları kontrol edecek fonksiyonları yazıyoruz, bu fonksiyonlar süslü parantezlerden önce throw -> String içermeli, String farklı olabilir
func checkPassword(_ password: String) throws -> String {
    if password.count < 5 {
        throw PasswordError.short
    }
    if password == "12345" {
        throw PasswordError.obvious
    }
    if password.count < 8 {
        return "OK"
    } else if password.count < 10 {
        return "Good"
    } else {
        return "Excellent"
    }
}
throw var diye illa hata fırlatacak değil
Bu fonksiyonu do try catch bloğu içinde yazarız
do{
	let passQuality = try checkPassword("12345")
	print("The password quality is \(passQuality)")
}catch PasswordError.short{
	print("Weak Password")
	error.localizedDescription
}
try! kullanırsak do catch bloklarına ihtiyacımız olmaz fakat hata alırsak program çöker

CLOSURES
Swiftin en kompleks yapılarından biri diyebiliriz
SwiftUI da çok fazla kullanılıyor
Değişkenlere doğrudan atayabildiğimiz fonksiyonlar diyebiliriz veya bir fonksiyonu başka bir fonksiyona parametre olarak veriyormuşuz gibi de düşünülebilir
func sayHello(){
	print("Hello")
}
var sayHello2 = sayHello
sayHello2()
Şu şekilde de yazabilirdik
var sayHello2 : () -> Void = sayHello
Burada parametre kısmını ='den sonra yapsaydık tuples ile karıştırılırdı
Fonksiyondan fonksiyon ürettik, o zaman doğrudan bir değişkenden de fonksiyon üretebiliriz
let sayHello3 = {
	print("Hello")
}
sayHello3()
Bu fonksiyonumsulara parametre verip return bile ettirebiliriz, bunun için "in" keywordunu kullanacağız ve bunu süslü parantezlerin içinde yapacağız, "in" keywordu body'nin nereden itibaren başladığını belirtecek
let sayHello4 = { (name:String) -> String in
		print("Hello \(name)")
} 
External parameter name sadece doğrudan fonksiyon oluşturduğumuz zaman önemli, closurlarda kullanmıyoruz!
Bazen bir fonksiyonu başka bir fonksiyona parametre olarak vermemiz gerekebilir, böyle durumlarda ayrıca fonksiyon yazmak yerine doğruca closurlardan faydalanabiliriz.Örneğin .sorted(by:customSortFunction) şeklinde fonksiyon alabilir. Bu fonksiyon 2 string almalı ve geriye bool döndürmeli
.sorted(by:{ (name1:String,name2:String) -> Bool in
	if(name1>name2){
		return true
	}
	return false
})
Colusurları neden kullanırız: İndirme bittikten sonra işlem yapacağımızda, animasyon tamamlanınca işlem yapacağımızda, delay vermek istediğimizde, menüden seçim yapıldığında işlem yapmak istediğimizde...
Hazır fonksiyonlara closure eklemek istediğimizde zaten istenen parametreler ve return type belli olduğundan bunları yazmaya da biliriz.
by:{name1,name2 in
Hatta by: da yazmayabiliriz
{name1,name2 in
Hatta parametre adlarını yazmayıp bunun yerine $0,$1 gibi swiftin default değerlerini de kullanabiliriz, böylece in keywordunu de kullanmamız gerekmez
{return $0 > $1}
Tek satıra düşünce return keywordunu de kullanmamız gerekmez
{$0 > $1}
.filter() ve .map() komutları da closure kullanabileceğimiz fonksiyolardır.
.filter() bir arrayin tüm elemanları üzerinde bir fonksiyon uygular ve true dönenleri yeni bir array olarak döndürür
.filter({$0.hasPrefix("Y")})
.öap() bir arrayin tüm elemanlarına verilen fonksiyonu uygular ve yeni array olarak döndürür
.map({$0.uppercased()})
Bir fonksiyon birden fazla closure alıyorsa, bu fonksiyonu çağırırken ilk closur normal çağırılıyor fakat sonrakiler için label da yazılmalı
doSomething(){
}label2:{
}label3:{
}
